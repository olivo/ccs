<?php

require "PHP-Parser-master/lib/bootstrap.php";
require "CFGNode.php";
require "StmtProcessing.php";

// Class representing an entire CFG.
// It contains an entry CFG node, and an exit CFG node.
// The CFG can be traversed by going through the successors of 
// the CFG nodes until the exit node.

class CFG {

      // Entry node.
      public $entry = NULL;

      // Exit node.
      public $exit = NULL;

      function __construct() {

      	       $this->entry = new CFGNode();
	       $this->exit = new CFGNode();

      }

	
	// Construct the Control Flow Graph (CFG) from a 
	// sequence of statements.

	static function construct_cfg($stmts) {
	
	       $cfg = new CFG();

	       $entry = new CFGNode();

	       $cfg->entry = $entry;
	       
	       $current_node = $entry;

	       foreach($stmts as $stmt)  {
	       	 if($stmt instanceof PhpParser\Node\Expr\Assign) {
		 	  print "Found assignment statement\n";
			  $assign_node = CFG::processExprAssign($stmt);
			  $current_node->successors[] = $assign_node;
			  $current_node = $assign_node;
			  print "Constructed assignment node\n";

		  }
		  else if($stmt instanceof PhpParser\Node\Stmt\If_) {
		          print "Found conditional statement\n";
			  $if_node = CFG::processStmtIf($stmt);
			  
		       	  print "Constructed conditional node\n";
		  }	       		      
	       		      
	          print "The statement has type ".($stmt->getType())."\n";
	          print "Has values\n";

		  foreach($stmt as $key => $value) {
			  print "Key=".($key)."\n";
		   }

	        }

	$cfg->exit = $current_node;

	$cfg->print_cfg();

	return $cfg;
					
}	

// Constructs a node for an assignment expression.
static function processExprAssign($exprAssign) {

	// exprAssign has keys 'var' and 'expr'.

	$cfg_node = new CFGNode();
	$cfg_node->stmt = $exprAssign;

	return $cfg_node;
}

// Constructs a node for an if statement.

static function processStmtIf($stmtIf) {

	// stmtIf has keys 'cond', 'stmts', 'elseifs', and 'else'.
	print("WARNING:Stmt If not handled properly.\n");
	$cfg_node = new CFGNode();

	// Get the If condition.
	$cond = $stmtIf->cond;
	
	// Get the statements for the first branch.
	$if_stmts = $stmtIf->stmts;

	print "The condition has type ".($stmtIf->cond->getType())."\n";
	return $cfg_node;
}

// Constructs a node for an include expression.
// WARNING: Not implemented;
static function processExprInclude($exprInclude) {

	// exprInclude has keys 'expr' and 'type'.
	print("WARNING:Expr Include not handled properly.\n");
	$cfg_node = new CFGNode();

	return $cfg_node;
}


// Prints a CFG starting from the root node.
// WARNING: Only considering assignment nodes.
function print_cfg() {
	 
	 print "Starting to print CFG\n";

	 // Skip the first node, because it's a dummy entry node.
	 $current_node=$this->entry;
	 $successor_list = $current_node->successors;
	 $current_node=$successor_list[0];
	 

	 while(count($current_node->successors)) {
	 	if($current_node instanceof PhpParser\Node\Expr\Assign)
	 			 print "Node with var:".(getVarFromExprAssignment($current_node->stmt))."\n";
		 
		$successor_list = $current_node->successors;
		$current_node=$successor_list[0];
	 }

	 if($current_node instanceof PhpParser\Node\Expr\Assign)
	 		  print "Last Node with var:".(getVarFromExprAssignment($current_node->stmt))."\n";

}

	

}

?>